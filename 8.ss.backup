(define  (slist-map proc slist)
  (let slist-map ([slist slist])
    (cond 
      [(null? slist) '()]
      [(symbol? (car slist)) (cons (proc (car slist)) (slist-map (cdr slist)))]
      [else (cons (slist-map (car slist))             
  (slist-map (cdr slist)))])))  
            

(define  (slist-reverse slist)
  (let slist-reverse ([slist slist])
    (cond 
          [(null? slist) '()]
          [(list? (car slist)) (append (slist-reverse (cdr slist)) (list (slist-reverse (car slist))))]
          [else (append (slist-reverse (cdr slist)) (list (car slist)))])))

(define (slist-depth slist) 
  (let notate ([slist slist] 
               [depth 0])
    (cond 
      [(null? slist) (+ 1 depth)]
      [(symbol? (car slist)) (max depth (notate (cdr slist) depth))]
      [else (max (notate (car slist) (+ 1 depth)) (notate (cdr slist) depth))])))


(define (slist-paren-count slist) 
  (let notate ([slist slist])
    (cond 
      [(null? slist) 2]
      [(symbol? (car slist)) (notate (cdr slist))]
      [else (+ (notate (car slist)) (notate (cdr slist)))])))
 
(define (slist-symbols-at-depth slist d) 
  (let notate ([slist slist] 
               [depth 1])
    (cond 
      [(null? slist) '()]
      [(and (symbol? (car slist)) (equal? depth d)) (cons (car slist) (notate (cdr slist) depth))]
      [(symbol? (car slist)) (notate (cdr slist) depth)]
      [else (append (notate (car slist) (+ 1 depth)) (notate (cdr slist) depth))])))
 
(define group-by-two
    (lambda (lst)
        (cond
            [(null? lst) '()]
            [(null? (cdr lst)) (list (list (car lst)))]
            [else (cons (list (car lst) (cadr lst)) (group-by-two (cddr lst)))]
        )))

